diff --git a/kernel/src/interrupts/idt.rs b/kernel/src/interrupts/idt.rs
index e8a66c2..163d104 100644
--- a/kernel/src/interrupts/idt.rs
+++ b/kernel/src/interrupts/idt.rs
@@ -68,6 +68,12 @@ impl<F> IdtEntry<F> {
         self.options = IdtEntryOptions::interrupt_gate(); // ‚≠ê ESTA L√çNEA
         self
     }
+
+    pub fn set_privilege_level(&mut self, dpl: u16) -> &mut Self {
+        // DPL est√° en bits 13-14 de options
+        self.options.0 = (self.options.0 & !0x6000) | ((dpl & 0b11) << 13);
+        self
+    }
 }
 
 // Para excepciones que reciben stack frame
diff --git a/kernel/src/main.rs b/kernel/src/main.rs
index ab9ff43..8a5d44b 100644
--- a/kernel/src/main.rs
+++ b/kernel/src/main.rs
@@ -24,7 +24,7 @@ use interrupts::idt::InterruptDescriptorTable;
 use spin::Once;
 use x86_64::{VirtAddr, structures::paging::FrameAllocator};
 use process::{Process, Pid, scheduler::SCHEDULER};
-use crate::allocator::FRAME_ALLOCATOR;
+use crate::{allocator::FRAME_ALLOCATOR, process::ProcessState};
 
 use crate::{
     framebuffer::{Color, init_global_framebuffer}, interrupts::exception::ExceptionStackFrame, memory::{frame_allocator::{self, BootInfoFrameAllocator}, paging::ActivePageTable}, repl::Repl
@@ -46,7 +46,10 @@ fn init_idt() {
         idt.add_handler_with_error(14, page_fault_handler);
         idt.add_handler(32, timer_handler);
         idt.add_handler(33, keyboard_interrupt_handler);
-        idt.entries[0x80].set_handler_addr(syscall_entry as u64);
+        // ‚úÖ FIX: INT 0x80 necesita DPL=3 para que Ring 3 pueda llamarla
+        idt.entries[0x80]
+            .set_handler_addr(syscall_entry as u64)
+            .set_privilege_level(3);  // ‚Üê AGREGAR ESTA L√çNEA
         idt
     });
 }
@@ -114,9 +117,27 @@ extern "x86-interrupt" fn page_fault_handler(
 }
 
 extern "x86-interrupt" fn timer_handler(_sf: &mut ExceptionStackFrame) {
-    // Por ahora, solo reconocer que ocurri√≥
+    // ‚úÖ AGREGAR: Hacer context switch peri√≥dico
+    static mut TICK: usize = 0;
+    unsafe {
+        TICK += 1;
+        if TICK >= 10 {  // Cada 10 ticks (100ms con PIT a 100Hz)
+            TICK = 0;
+            
+            // Hacer context switch
+            use process::context::switch_context;
+            let switch_info = {
+                let mut scheduler = process::scheduler::SCHEDULER.lock();
+                scheduler.switch_to_next()
+            };
+            
+            if let Some((old_ctx, new_ctx)) = switch_info {
+                switch_context(old_ctx, new_ctx);
+            }
+        }
+    }
     
-    // Enviar EOI (End of Interrupt) al PIC
+    // Enviar EOI
     unsafe {
         use x86_64::instructions::port::PortWriteOnly;
         PortWriteOnly::<u8>::new(0x20).write(0x20);
@@ -267,47 +288,68 @@ fn kernel_main(boot_info: &'static mut BootInfo) -> ! {
         core::arch::asm!("sti");
     }
 
-    // Justo despu√©s de:
-    // serial_println!("Step 7: Paging initialized");
+    // Inicializar el PIT
+    pit::init(100); // 100 Hz
+
+    let mut repl = Repl::new(10, 50);
+    repl.show_prompt();
 
-    serial_println!("Step 7.5: Pre-mapping user stack for Ring 3");
+    serial_println!("Step 9: Initializing TSS and GDT");
+    process::tss::init();
 
-    // Direcci√≥n fija para el user stack (usamos una regi√≥n alta en user space)
-    const USER_STACK_TOP: u64 = 0x0000_7000_0000_2000;  // 2 p√°ginas antes de aqu√≠
-    const USER_STACK_SIZE: u64 = 8192;  // 2 p√°ginas (8KB)
-    const USER_STACK_BASE: u64 = USER_STACK_TOP - USER_STACK_SIZE;
+    serial_println!("Step 7.5: Setting up user space memory");
 
     unsafe {
         let phys_offset = memory::physical_memory_offset();
         let mut page_table = memory::paging::ActivePageTable::new(phys_offset);
         let mut frame_allocator_lock = FRAME_ALLOCATOR.lock();
         
-        // ‚úÖ Unwrap el Option
         let frame_allocator = frame_allocator_lock.as_mut()
             .expect("Frame allocator not initialized");
         
+        // ============ 1. Mapear USER STACK ============
+        const USER_STACK_TOP: u64 = 0x0000_7000_0000_2000;
+        const USER_STACK_SIZE: u64 = 8192;  // 2 p√°ginas
+        const USER_STACK_BASE: u64 = USER_STACK_TOP - USER_STACK_SIZE;
+        
         memory::user_pages::map_user_pages(
             &mut page_table.mapper,
-            frame_allocator,  // ‚Üê Ya no es Option
+            frame_allocator,
             VirtAddr::new(USER_STACK_BASE),
             (USER_STACK_SIZE / 4096) as usize,
         ).expect("Failed to map user stack");
         
         serial_println!(
-            "User stack mapped: {:#x} - {:#x}",
+            "  User stack: {:#x} - {:#x}",
             USER_STACK_BASE,
             USER_STACK_TOP
         );
-    }
-
-    // Inicializar el PIT
-    pit::init(100); // 100 Hz
+        
+        // ============ 2. Mapear y COPIAR USER CODE ============
+        use memory::user_code;
+        use process::user_test_minimal;
 
-    let mut repl = Repl::new(10, 50);
-    repl.show_prompt();
+        // ‚úÖ Imprimir tests disponibles
+        user_test_minimal::print_available_tests();
+        
+        // ‚úÖ Elegir test (cambia esto para probar diferentes tests)
+        let test_name = "syscall";  // Opciones: "loop", "hlt", "syscall", "stack", "nop"
+        let test_ptr = user_test_minimal::get_test_ptr(test_name);
+        
+        serial_println!("\nüìù Using test: '{}'", test_name);
+        serial_println!("   Test address: {:#x}", test_ptr as u64);
+        
+        let code_entry = user_code::setup_user_code(
+            &mut page_table.mapper,
+            frame_allocator,
+            test_ptr,
+            4096,  // 1 p√°gina suficiente para tests simples
+        ).expect("Failed to setup user code");
+        
+        serial_println!("  ‚úÖ User code copied to: {:#x}\n", code_entry.as_u64());
+    }
 
-    serial_println!("Step 9: Initializing TSS and GDT");
-    process::tss::init();
+    // ============ CREAR PROCESOS (REEMPLAZAR LA SECCI√ìN EXISTENTE) ============
 
     serial_println!("Step 10: Creating test processes");
 
@@ -321,37 +363,45 @@ fn kernel_main(boot_info: &'static mut BootInfo) -> ! {
             frame
         };
         
-        let idle = Box::new(Process::new(
+        let mut idle = Box::new(Process::new(
             pid,
             VirtAddr::new(idle_task as *const () as u64),
             page_table,
         ));
+        idle.state = ProcessState::Ready;  // ‚Üê Marcar como Ready
+        idle.set_name("idle");
         
         scheduler.add_process(idle);
     }
 
-    // Si activamos esto: Kernel panic! por error de proteccion
-    // (aparentemente falta USER_ACCESSIBLE)
-    // // ‚úÖ NUEVO: Proceso en user space (Ring 3)
-    // {
-    //     let mut scheduler = SCHEDULER.lock();
-    //     let pid = scheduler.allocate_pid();
+    // ‚úÖ Proceso en user space (Ring 3) - CON DEBUGGING
+    {
+        use memory::user_code::USER_CODE_BASE;
         
-    //     let page_table = unsafe {
-    //         let (frame, _) = x86_64::registers::control::Cr3::read();
-    //         frame
-    //     };
+        let mut scheduler = SCHEDULER.lock();
+        let pid = scheduler.allocate_pid();
         
-    //     let mut proc = Box::new(Process::new_user(
-    //         pid,
-    //         VirtAddr::new(process::user_test_function as *const () as u64),
-    //         page_table,
-    //     ));
-    //     proc.set_name("user_test")   ;
+        let page_table = unsafe {
+            let (frame, _) = x86_64::registers::control::Cr3::read();
+            frame
+        };
+        
+        // ‚úÖ NUEVO: Pasar nombre del test
+        let test_name = "syscall";  // Debe coincidir con el test copiado arriba
+        
+        let mut proc = Box::new(Process::new_user(
+            pid,
+            VirtAddr::new(USER_CODE_BASE),
+            page_table,
+            Some(test_name),  // ‚Üê Nuevo par√°metro
+        ));
+        proc.state = ProcessState::Ready;
+        proc.set_name("user_test");
         
-    //     scheduler.add_process(proc);
-    // }
+        scheduler.add_process(proc);
+    }
 
+    // Proceso shell (kernel space por ahora)
     {
         let mut scheduler = SCHEDULER.lock();
         let pid = scheduler.allocate_pid();
@@ -366,12 +416,13 @@ fn kernel_main(boot_info: &'static mut BootInfo) -> ! {
             VirtAddr::new(shell_process as *const () as u64),
             page_table,
         ));
+        proc.state = ProcessState::Ready;  // ‚Üê Marcar como Ready
         proc.set_name("shell");
         
         scheduler.add_process(proc);
     }
 
-    serial_println!("Processes created!");
+    serial_println!("All processes created!");
 
     loop {
         // ‚úÖ Main loop SOLO hace scheduling
diff --git a/kernel/src/memory/mod.rs b/kernel/src/memory/mod.rs
index 76af061..9856841 100644
--- a/kernel/src/memory/mod.rs
+++ b/kernel/src/memory/mod.rs
@@ -6,6 +6,7 @@ use core::sync::atomic::{AtomicU64, Ordering};
 pub mod paging;
 pub mod frame_allocator;
 pub mod user_pages;
+pub mod user_code;  // ‚Üê NUEVO
 
 static PHYSICAL_MEMORY_OFFSET: AtomicU64 = AtomicU64::new(0);
 
diff --git a/kernel/src/process/context.rs b/kernel/src/process/context.rs
index 8d74453..e6bb8b7 100644
--- a/kernel/src/process/context.rs
+++ b/kernel/src/process/context.rs
@@ -1,25 +1,31 @@
 // kernel/src/process/context.rs
+// Basado en xv6's context
 
 use x86_64::VirtAddr;
 
-/// Contexto del CPU (registros guardados durante context switch)
+use crate::serial_println;
+
+/// Contexto del CPU para context switch en KERNEL MODE
+/// 
+/// Solo contiene registros callee-saved (System V ABI)
+/// NO se usa para saltar a user mode - para eso est√° TrapFrame
 #[repr(C)]
 #[derive(Debug, Clone, Copy)]
 pub struct Context {
-    // Registros de prop√≥sito general (callee-saved en System V ABI)
+    // Callee-saved registers (System V ABI)
     pub r15: u64,
     pub r14: u64,
     pub r13: u64,
     pub r12: u64,
     pub rbx: u64,
     pub rbp: u64,
-
-    // Instruction pointer (donde reanudar)
+    
+    // Instruction pointer (donde reanudar en kernel mode)
     pub rip: u64,
 }
 
 impl Context {
-    /// Crea un contexto nuevo apuntando a entry_point
+    /// Crea un contexto que apunta a una funci√≥n de kernel
     pub fn new(entry_point: VirtAddr, stack: VirtAddr) -> Self {
         Self {
             r15: 0,
@@ -27,12 +33,12 @@ impl Context {
             r13: 0,
             r12: 0,
             rbx: 0,
-            rbp: stack.as_u64(),  // Stack pointer inicial
+            rbp: stack.as_u64(),
             rip: entry_point.as_u64(),
         }
     }
 
-    /// Crea un contexto vac√≠o (para el proceso idle)
+    /// Crea un contexto vac√≠o (para proceso idle)
     pub const fn empty() -> Self {
         Self {
             r15: 0,
@@ -45,16 +51,22 @@ impl Context {
         }
     }
 
-    /// ‚úÖ NUEVO: Contexto para proceso de usuario con trampol√≠n
-    pub fn new_user(entry_point: VirtAddr, kernel_stack: VirtAddr, user_stack: VirtAddr) -> Self {
-        // En lugar de ir directo al entry_point, vamos al trampol√≠n
-        let mut ctx = Self::new(VirtAddr::new(user_trampoline as u64), kernel_stack);
+    /// ‚úÖ NUEVO: Crea un contexto que apunta a forkret
+    /// (primera funci√≥n que ejecuta un proceso user cuando se schedulea)
+    pub fn new_for_user_process(kernel_stack: VirtAddr) -> Self {
+        extern "C" {
+            fn forkret();
+        }
         
-        // Usamos registros callee-saved para pasar datos al trampol√≠n
-        // switch_context restaurar√° estos valores antes de que corra el trampol√≠n
-        ctx.r12 = entry_point.as_u64(); // R12 = D√≥nde saltar en Ring 3
-        ctx.r13 = user_stack.as_u64();  // R13 = Stack de Ring 3
-        ctx
+        Self {
+            r15: 0,
+            r14: 0,
+            r13: 0,
+            r12: 0,
+            rbx: 0,
+            rbp: kernel_stack.as_u64(),
+            rip: forkret as u64,
+        }
     }
 }
 
@@ -73,7 +85,7 @@ pub unsafe extern "C" fn switch_context(old: *mut Context, new: *const Context)
         "mov [rdi + 0x28], rbp",
         
         // Guardar rip (direcci√≥n de retorno)
-        "mov rax, [rsp]",        // Leer return address del stack
+        "mov rax, [rsp]",
         "mov [rdi + 0x30], rax",
         
         // Cargar nuevo contexto
@@ -86,28 +98,41 @@ pub unsafe extern "C" fn switch_context(old: *mut Context, new: *const Context)
         
         // Saltar al nuevo rip
         "mov rax, [rsi + 0x30]",
-        "mov [rsp], rax",        // Poner nuevo rip en el stack
+        "mov [rsp], rax",
         
-        "ret",                   // Saltar al nuevo contexto
-        // options(noreturn)
+        "ret",
     );
 }
 
-/// ‚úÖ NUEVO: Trampol√≠n que lleva de Kernel -> User
-#[unsafe(naked)]
-unsafe extern "C" fn user_trampoline() {
-    core::arch::naked_asm!(
-        // Al llegar aqu√≠, switch_context ya restaur√≥ R12 y R13
-        // R12 contiene el entry_point de usuario
-        // R13 contiene el user_stack
+/// forkret: Primera funci√≥n que ejecuta un proceso user
+/// Hace cleanup y llama a trapret
+#[no_mangle]
+extern "C" fn forkret() {
+    // TODO: Aqu√≠ podr√≠as hacer cleanup (como en xv6)
+    // Por ahora, directamente llamamos a trapret
+    
+    unsafe {
+        // Obtener el proceso actual
+        let mut scheduler = crate::process::scheduler::SCHEDULER.lock();
         
-        "mov rdi, r12", // Primer argumento para jump_to_userspace
-        "mov rsi, r13", // Segundo argumento para jump_to_userspace
-        
-        // Llamar a la funci√≥n que hace la magia (IRETQ)
-        // Esta funci√≥n NO retorna
-        "call jump_to_userspace",
+        if let Some(pid) = scheduler.current {
+            if let Some(proc) = scheduler.processes.iter_mut().find(|p| p.pid == pid) {
+                crate::serial_println!("forkret: PID {} entering userspace", pid.0);
+                
+                // Obtener puntero al trapframe
+                if let Some(ref tf) = proc.trapframe {
+                    // ‚úÖ FIX: Usar &**tf para obtener &TrapFrame desde &Box<TrapFrame>
+                    let tf_ptr = &**tf as *const super::trapframe::TrapFrame;
+                    
+                    // Liberar el lock antes de IRETQ
+                    drop(scheduler);
+                    
+                    // Nunca retorna
+                    super::trapret::trapret_debug(tf_ptr);
+                }
+            }
+        }
         
-        "ud2" // Trap por si acaso retorna (no deber√≠a)
-    );
+        panic!("forkret: No process to return to!");
+    }
 }
\ No newline at end of file
diff --git a/kernel/src/process/mod.rs b/kernel/src/process/mod.rs
index 0e14d6f..ce4433d 100644
--- a/kernel/src/process/mod.rs
+++ b/kernel/src/process/mod.rs
@@ -1,19 +1,20 @@
 // kernel/src/process/mod.rs
+// Arquitectura basada en xv6
 
 use alloc::boxed::Box;
-use x86_64::{
-    VirtAddr,
-    structures::paging::{FrameAllocator, Mapper, Page, PageTable, PageTableFlags, PhysFrame, Size4KiB},
-};
-use crate::memory::user_pages::map_user_pages;
+use x86_64::{VirtAddr, structures::paging::PhysFrame};
 
 pub mod context;
 pub mod syscall;
 pub mod tss;
-pub mod userspace;
+pub mod trapframe;
+pub mod trapret;
 pub mod scheduler;
+pub mod userspace;
+pub mod user_test_minimal;
 
 use context::Context;
+use trapframe::TrapFrame;
 
 /// Process ID
 #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
@@ -22,9 +23,10 @@ pub struct Pid(pub usize);
 /// Estado del proceso
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
 pub enum ProcessState {
+    Embryo,     // En creaci√≥n
     Ready,      // Listo para ejecutar
     Running,    // Ejecut√°ndose actualmente
-    Blocked,    // Esperando I/O
+    Sleeping,   // Esperando I/O
     Zombie,     // Terminado pero no recolectado
 }
 
@@ -36,14 +38,27 @@ pub enum PrivilegeLevel {
 }
 
 /// Process Control Block (PCB)
+/// 
+/// Arquitectura similar a xv6:
+/// - `context`: Estado del kernel (para context switch)
+/// - `trapframe`: Estado de usuario (guardado en trap/syscall)
+/// - `kernel_stack`: Stack que usa cuando est√° en kernel mode
 pub struct Process {
     pub pid: Pid,
     pub state: ProcessState,
+    
+    // ============ Context Switching (Kernel Mode) ============
     pub context: Context,
     pub kernel_stack: VirtAddr,
-    pub user_stack: Option<VirtAddr>,
-    pub privilege: PrivilegeLevel, 
+    
+    // ============ User Mode State ============
+    pub trapframe: Option<Box<TrapFrame>>,  // Solo para procesos user
+    pub privilege: PrivilegeLevel,
+    
+    // ============ Memory Management ============
     pub page_table: PhysFrame,
+    
+    // ============ Metadata ============
     pub name: [u8; 32],
 }
 
@@ -56,15 +71,15 @@ impl Process {
             if ptr.is_null() {
                 panic!("Failed to allocate kernel stack");
             }
-            VirtAddr::new(ptr as u64 + 8192)
+            VirtAddr::new(ptr as u64 + 8192)  // Top of stack
         };
 
         Self {
             pid,
-            state: ProcessState::Ready,
+            state: ProcessState::Embryo,
             context: Context::new(entry_point, kernel_stack),
             kernel_stack,
-            user_stack: None,
+            trapframe: None,  // Kernel processes don't need trapframe
             privilege: PrivilegeLevel::Kernel,
             page_table,
             name: [0; 32],
@@ -72,8 +87,16 @@ impl Process {
     }
 
     /// Crea un proceso de user space (Ring 3)
-    pub fn new_user(pid: Pid, entry_point: VirtAddr, page_table: PhysFrame) -> Self {
-        // Kernel stack
+    /// 
+    /// # Arguments
+    /// * `test_name` - Nombre del test: "loop", "hlt", "syscall", "stack", "nop"
+    pub fn new_user(
+        pid: Pid,
+        entry_point: VirtAddr,
+        page_table: PhysFrame,
+        test_name: Option<&str>
+    ) -> Self {
+        // Allocar kernel stack
         let kernel_stack = unsafe {
             let layout = core::alloc::Layout::from_size_align(8192, 4096).unwrap();
             let ptr = alloc::alloc::alloc(layout);
@@ -83,16 +106,49 @@ impl Process {
             VirtAddr::new(ptr as u64 + 8192)
         };
 
-        // ‚úÖ User stack: Usar la direcci√≥n que pre-mapeamos en main.rs
+        // ‚úÖ FIX: User stack - RSP debe apuntar DENTRO de la regi√≥n mapeada
         const USER_STACK_TOP: u64 = 0x0000_7000_0000_2000;
-        let user_stack = VirtAddr::new(USER_STACK_TOP);
+        const USER_STACK_SIZE: u64 = 8192;
+        
+        // ‚ö†Ô∏è IMPORTANTE: Stack crece hacia abajo, RSP debe estar dentro
+        // Si mapeamos [BASE, TOP), RSP debe estar en TOP - 8 (no en TOP)
+        let user_rsp = USER_STACK_TOP - 8;
+        
+        // Obtener selectores
+        let (user_cs, user_ss) = tss::get_user_selectors();
+        
+        // Crear trapframe
+        let trapframe = Box::new(TrapFrame::new_user(
+            entry_point.as_u64(),
+            user_rsp,  // ‚úÖ Ahora apunta a memoria v√°lida
+            user_cs.0 as u64,
+            user_ss.0 as u64,
+        ));
+
+        // Context apunta a forkret
+        let context = Context::new_for_user_process(kernel_stack);
+
+        // Log detallado
+        crate::serial_println!("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
+        crate::serial_println!("‚ïë CREATING USER PROCESS                                  ‚ïë");
+        crate::serial_println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
+        crate::serial_println!("‚ïë PID:         {}                                         ‚ïë", pid.0);
+        crate::serial_println!("‚ïë Entry:       {:#018x}                        ‚ïë", entry_point.as_u64());
+        crate::serial_println!("‚ïë User RSP:    {:#018x}                        ‚ïë", user_rsp);
+        crate::serial_println!("‚ïë Kernel RSP:  {:#018x}                        ‚ïë", kernel_stack.as_u64());
+        crate::serial_println!("‚ïë CS selector: {:#018x} (RPL={})                    ‚ïë", user_cs.0, user_cs.0 & 3);
+        crate::serial_println!("‚ïë SS selector: {:#018x} (RPL={})                    ‚ïë", user_ss.0, user_ss.0 & 3);
+        if let Some(test) = test_name {
+            crate::serial_println!("‚ïë Test:        {}                                         ‚ïë", test);
+        }
+        crate::serial_println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
 
         Self {
             pid,
-            state: ProcessState::Ready,
-            context: Context::new_user(entry_point, kernel_stack, user_stack),
+            state: ProcessState::Embryo,
+            context,
             kernel_stack,
-            user_stack: Some(user_stack),
+            trapframe: Some(trapframe),
             privilege: PrivilegeLevel::User,
             page_table,
             name: [0; 32],
@@ -106,46 +162,20 @@ impl Process {
     }
 }
 
-/// Yield CPU para permitir context switch
-pub fn yield_cpu() {
-    use context::switch_context;
-    
-    let switch_info = {
-        let mut scheduler = scheduler::SCHEDULER.lock();
-        scheduler.switch_to_next()
-    };
-    
-    if let Some((old_ctx, new_ctx)) = switch_info {
-        unsafe {
-            switch_context(old_ctx, new_ctx);
-        }
-    }
-}
-
-/// Funci√≥n de prueba que ejecuta en Ring 3
+/// ‚ùå DEPRECADO: No usar esto - usa los tests m√≠nimos
 #[no_mangle]
 pub extern "C" fn user_test_function() -> ! {
-    // Obtener PID
-    let pid = userspace::sys_getpid();
+    // Este c√≥digo puede no funcionar porque:
+    // 1. Usa syscalls que asumen TLS
+    // 2. Puede usar instrucciones privilegiadas
+    // 3. No est√° dise√±ado para Ring 3
     
-    // Mensaje de prueba
-    let msg = b"Hello from userspace! PID=";
-    userspace::sys_write(1, msg.as_ptr(), msg.len());
+    crate::serial_println!("‚ö†Ô∏è  WARNING: user_test_function() is deprecated");
+    crate::serial_println!("   Use user_test_minimal tests instead");
     
-    // ‚úÖ FIX: Usar array est√°tico o escribir char por char
-    if pid < 10 {
-        let c = b'0' + pid as u8;
-        userspace::sys_write(1, &c as *const u8, 1);
-    } else {
-        let tens = b'0' + (pid / 10) as u8;
-        let ones = b'0' + (pid % 10) as u8;
-        userspace::sys_write(1, &tens as *const u8, 1);
-        userspace::sys_write(1, &ones as *const u8, 1);
+    loop {
+        unsafe {
+            core::arch::asm!("hlt");
+        }
     }
-    
-    let newline = b"\n";
-    userspace::sys_write(1, newline.as_ptr(), newline.len());
-    
-    // Salir con status 0
-    userspace::sys_exit(0);
 }
\ No newline at end of file
diff --git a/kernel/src/process/scheduler.rs b/kernel/src/process/scheduler.rs
index 8241f88..5a52777 100644
--- a/kernel/src/process/scheduler.rs
+++ b/kernel/src/process/scheduler.rs
@@ -69,7 +69,7 @@ impl Scheduler {
                 proc.state = ProcessState::Running;
                 self.current = Some(proc.pid);
                 
-                let pid = proc.pid;
+                let _pid = proc.pid;
                 self.processes.push_back(proc);
                 
                 // Retornar referencia mutable
@@ -82,7 +82,7 @@ impl Scheduler {
         None
     }
 
-        /// ‚úÖ NUEVO: Hace context switch y retorna (proceso_anterior, proceso_siguiente)
+    /// ‚úÖ Hace context switch y retorna (proceso_anterior, proceso_siguiente)
     /// Retorna None si no hay cambio de contexto necesario
     pub fn switch_to_next(&mut self) -> Option<(*mut Context, *const Context)> {
         if self.processes.is_empty() {
@@ -157,11 +157,11 @@ impl Scheduler {
         None
     }
 
-    /// Marca el proceso actual como bloqueado
+    /// Marca el proceso actual como bloqueado (sleeping)
     pub fn block_current(&mut self) {
         if let Some(current_pid) = self.current {
             if let Some(proc) = self.processes.iter_mut().find(|p| p.pid == current_pid) {
-                proc.state = ProcessState::Blocked;
+                proc.state = ProcessState::Sleeping;  // ‚úÖ FIX: Blocked -> Sleeping
             }
         }
     }
@@ -169,32 +169,15 @@ impl Scheduler {
     /// Desbloquea un proceso
     pub fn unblock(&mut self, pid: Pid) {
         if let Some(proc) = self.processes.iter_mut().find(|p| p.pid == pid) {
-            if proc.state == ProcessState::Blocked {
+            if proc.state == ProcessState::Sleeping {  // ‚úÖ FIX: Blocked -> Sleeping
                 proc.state = ProcessState::Ready;
             }
         }
     }
 
-    /// Ejecuta el proceso seleccionado
-    /// Si es user space, salta a Ring 3
-    pub unsafe fn run_process(&mut self, process: &mut Process) {
-        match process.privilege {
-            PrivilegeLevel::Kernel => {
-                // Ya est√° en kernel, solo hacer context switch normal
-                // (esto ya lo manejas con switch_to_next)
-            }
-            PrivilegeLevel::User => {
-                // Saltar a user space
-                if let Some(user_stack) = process.user_stack {
-                    let entry = VirtAddr::new(process.context.rip);
-                    
-                    // Actualizar TSS con el kernel stack de este proceso
-                    crate::process::userspace::jump_to_userspace(entry, user_stack);
-                    
-                    // ‚ö†Ô∏è ESTO NUNCA RETORNA (salta a ring 3)
-                    // super::userspace::jump_to_userspace(entry, user_stack);
-                }
-            }
-        }
-    }
+    // ‚ùå REMOVIDO: run_process() - Ya no se usa con la nueva arquitectura
+    // El flow correcto es:
+    // 1. switch_context() salta a forkret (primera vez)
+    // 2. forkret llama a trapret
+    // 3. trapret hace IRETQ a user mode
 }
\ No newline at end of file
diff --git a/kernel/src/process/syscall.rs b/kernel/src/process/syscall.rs
index adf69f9..3d037b5 100644
--- a/kernel/src/process/syscall.rs
+++ b/kernel/src/process/syscall.rs
@@ -2,7 +2,7 @@
 
 use core::arch::global_asm;
 
-// ‚úÖ NUEVO: Assembly correcto que preserva TODOS los registros
+// ‚úÖ Assembly correcto que preserva TODOS los registros
 global_asm!(
     ".global syscall_entry",
     "syscall_entry:",
@@ -52,7 +52,7 @@ global_asm!(
     "iretq",
 );
 
-// ‚úÖ NUEVO: Estructura que representa los registros guardados
+// ‚úÖ Estructura que representa los registros guardados
 #[repr(C)]
 struct SavedRegisters {
     r15: u64,
@@ -72,7 +72,7 @@ struct SavedRegisters {
     rax: u64,
 }
 
-// ‚úÖ NUEVO: Wrapper que lee los registros del stack
+// ‚úÖ Wrapper que lee los registros del stack
 #[no_mangle]
 extern "C" fn syscall_handler_asm(regs: &SavedRegisters) -> i64 {
     syscall_handler(
@@ -86,10 +86,6 @@ extern "C" fn syscall_handler_asm(regs: &SavedRegisters) -> i64 {
     )
 }
 
-// ‚ùå BORRAR ESTO (el wrapper viejo):
-// #[no_mangle]
-// extern "C" fn syscall_handler_wrapper(...) { ... }
-
 /// N√∫meros de syscall compatibles con Linux x86_64
 #[derive(Debug, Clone, Copy)]
 #[repr(u64)]
@@ -219,8 +215,20 @@ fn sys_exit(status: i32) -> SyscallResult {
         }
     }
     
+    // ‚úÖ FIX: Hacer yield manualmente en lugar de llamar a yield_cpu()
     loop {
-        super::yield_cpu();
+        use super::context::switch_context;
+        
+        let switch_info = {
+            let mut scheduler = super::scheduler::SCHEDULER.lock();
+            scheduler.switch_to_next()
+        };
+        
+        if let Some((old_ctx, new_ctx)) = switch_info {
+            unsafe {
+                switch_context(old_ctx, new_ctx);
+            }
+        }
     }
 }
 
diff --git a/kernel/src/process/userspace.rs b/kernel/src/process/userspace.rs
index 8c336b1..f058db2 100644
--- a/kernel/src/process/userspace.rs
+++ b/kernel/src/process/userspace.rs
@@ -10,6 +10,7 @@ use core::arch::asm;
 /// - `user_stack` debe apuntar a memoria v√°lida
 #[no_mangle]
 pub unsafe extern "C" fn jump_to_userspace(entry_point: VirtAddr, user_stack: VirtAddr) -> ! {
+    crate::serial_println!("funcion jump_to_userspace");
     let (user_cs, user_ds) = super::tss::get_user_selectors();
     
     let user_cs_val = user_cs.0 as u64 | 3;
diff --git a/out.txt b/out.txt
index 4b2ebc4..2c01025 100644
--- a/out.txt
+++ b/out.txt
@@ -1,941 +1,216 @@
-[2J[001;001H[=3h[2J[001;001H[2J[001;001H[8;056;240t[2J[001;001H[2J[001;001H[=3h[2J[001;001H[2J[001;001H[8;042;160t[2J[001;001HBdsDxe: loading Boot0002 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1,0x1)/Ata(Primary,Master,0x0)
-BdsDxe: starting Boot0002 "UEFI QEMU HARDDISK QM00001 " from PciRoot(0x0)/Pci(0x1,0x1)/Ata(Primary,Master,0x0)
-INFO : Framebuffer info: FrameBufferInfo { byte_len: 4096000, width: 1280, height: 800, pixel_format: Bgr, bytes_per_pixel: 4, stride: 1280 }
-INFO : UEFI bootloader started
-INFO : Using framebuffer at 0x80000000
-INFO : Reading configuration from disk was successful
-INFO : Trying to load ramdisk via Disk
-INFO : Ramdisk not found.
-TRACE: exiting boot services
-TRACE: switching to new level 4 table
-INFO : New page table at: PhysFrame[4KiB](0x101000)
-INFO : Elf file loaded at Pointer {
-    addr: 0x000000000e1d3000,
-    metadata: 1858112,
-}
-INFO : virtual_address_offset: 0x10000000000
-INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(4), offset: 0, virtual_addr: 0, physical_addr: 0, file_size: 7c3c, mem_size: 7c3c, align: 1000 })
-INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(5), offset: 7c40, virtual_addr: 8c40, physical_addr: 8c40, file_size: 1e4f5, mem_size: 1e4f5, align: 1000 })
-INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(6), offset: 26138, virtual_addr: 28138, physical_addr: 28138, file_size: 2398, mem_size: 2ec8, align: 1000 })
-INFO : Mapping bss section
-INFO : Handling Segment: Ph64(ProgramHeader64 { type_: Ok(Load), flags: Flags(6), offset: 284d0, virtual_addr: 2b4d0, physical_addr: 2b4d0, file_size: 254, mem_size: b5b0, align: 1000 })
-INFO : Mapping bss section
-INFO : Entry point at: 0x1000001cb10
-INFO : Creating GDT at PhysAddr(0x12e000)
-INFO : Map framebuffer
-INFO : Map physical memory
-INFO : Allocate bootinfo
-INFO : Create Memory Map
-INFO : Create bootinfo
-INFO : Jumping to kernel entry point at VirtAddr(0x1000001cb10)
-Step 8: Printing Buddy stats (lock released)
-Buddy Allocator Stats:
-  Total memory: 243MB
-  Order 12: 107 blocks of 4KB
-  Order 13: 77 blocks of 8KB
-  Order 14: 53 blocks of 16KB
-  Order 15: 28 blocks of 32KB
-  Order 16: 19 blocks of 64KB
-  Order 17: 13 blocks of 128KB
-  Order 18: 9 blocks of 256KB
-  Order 19: 8 blocks of 512KB
-  Order 20: 8 blocks of 1MB
-  Order 21: 8 blocks of 2MB
-  Order 22: 4 blocks of 4MB
-  Order 23: 2 blocks of 8MB
-  Order 24: 1 blocks of 16MB
-  Order 25: 3 blocks of 32MB
-  Order 26: 1 blocks of 64MB
-Buddy: Allocated 0xfec9000, order=12 (exact fit)
-Slab: Expanded 8B cache (+512 objects)
-  SUCCESS: Got pointer 0x2800fec9ff8
-  Write/read test: 0xdeadbeef
-  SUCCESS: Deallocation complete
-  Creating Vec...
-  Pushing elements...
-  Vec OK: len=3
-  Creating String...
-Buddy: Allocated 0xfec8000, order=12 (exact fit)
-Slab: Expanded 16B cache (+256 objects)
-  String test: Hello Slab!
-Slab Allocator Stats:
-  8B: 0/512 objects (0% used)
-  16B: 0/256 objects (0% used)
-Step 9: Initializing TSS and GDT
-TSS and GDT initialized
-Step 10: Creating test processes
->>> allocate_large: start
->>> allocate_large: order=12
-Buddy: Allocated 0xfec7000, order=12 (exact fit)
->>> allocate_large: OK
-Buddy: Allocated 0xfec6000, order=12 (exact fit)
-Slab: Expanded 256B cache (+16 objects)
-Scheduler: Added process PID 0
-Buddy: Allocated 0xfe8f000, order=12 (exact fit)
-Slab: Expanded 32B cache (+128 objects)
->>> allocate_large: start
->>> allocate_large: order=12
-Buddy: Allocated 0xfe8e000, order=12 (exact fit)
->>> allocate_large: OK
-Scheduler: Added process PID 1
-Processes created!
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
-Context switch: 0 -> 1
-Context switch: 1 -> 0
+warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
+package:   /home/oriaj/Prog/Rust/rust_so_kernel/kernel/Cargo.toml
+workspace: /home/oriaj/Prog/Rust/rust_so_kernel/Cargo.toml
+   Compiling kernel v0.1.0 (/home/oriaj/Prog/Rust/rust_so_kernel/kernel)
+error: the `noreturn` option cannot be used with `naked_asm!`
+  --> kernel/src/process/trapret.rs:48:17
+   |
+48 |         options(noreturn)
+   |                 ^^^^^^^^ the `noreturn` option is not meaningful for global-scoped inline assembly
+
+error: the `noreturn` option cannot be used with `naked_asm!`
+   --> kernel/src/process/trapret.rs:103:17
+    |
+103 |         options(noreturn)
+    |                 ^^^^^^^^ the `noreturn` option is not meaningful for global-scoped inline assembly
+
+error[E0425]: cannot find function `yield_cpu` in module `super`
+   --> kernel/src/process/syscall.rs:223:16
+    |
+223 |         super::yield_cpu();
+    |                ^^^^^^^^^ not found in `super`
+    |
+help: consider importing this function
+    |
+  3 + use crate::yield_cpu;
+    |
+help: if you import `yield_cpu`, refer to it directly
+    |
+223 -         super::yield_cpu();
+223 +         yield_cpu();
+    |
+
+error[E0658]: the `!` type is experimental
+  --> kernel/src/memory/user_code.rs:99:16
+   |
+99 |     F: Fn() -> !,
+   |                ^
+   |
+   = note: see issue #35121 <https://github.com/rust-lang/rust/issues/35121> for more information
+   = help: add `#![feature(never_type)]` to the crate attributes to enable
+   = note: this compiler was built on 2026-01-13; consider upgrading it if it is out of date
+
+warning: unused import: `self`
+ --> kernel/src/allocator/slab.rs:4:17
+  |
+4 | use core::ptr::{self, null_mut, NonNull};
+  |                 ^^^^
+  |
+  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default
+
+warning: unused imports: `FrameAllocator`, `Mapper`, `PageTableFlags`, `Page`, `Size4KiB`, and `VirtAddr`
+ --> kernel/src/allocator/mod.rs:9:5
+  |
+9 |     VirtAddr, structures::paging::{FrameAllocator, Mapper, Page, PageTableFlags, Size4KiB}
+  |     ^^^^^^^^                       ^^^^^^^^^^^^^^  ^^^^^^  ^^^^  ^^^^^^^^^^^^^^  ^^^^^^^^
+
+warning: unused import: `crate::debug_log`
+ --> kernel/src/keyboard.rs:3:5
+  |
+3 | use crate::debug_log;
+  |     ^^^^^^^^^^^^^^^^
+
+warning: unused import: `PhysFrame`
+ --> kernel/src/memory/user_pages.rs:6:15
+  |
+6 |         Page, PhysFrame, Size4KiB, PageTableFlags,
+  |               ^^^^^^^^^
+
+warning: unused import: `PhysAddr`
+ --> kernel/src/memory/user_code.rs:5:15
+  |
+5 |     VirtAddr, PhysAddr,
+  |               ^^^^^^^^
+
+warning: unused import: `core::arch::asm`
+ --> kernel/src/process/trapret.rs:4:5
+  |
+4 | use core::arch::asm;
+  |     ^^^^^^^^^^^^^^^
+
+warning: unused imports: `format` and `vec::Vec`
+  --> kernel/src/main.rs:19:25
+   |
+19 | use alloc::{boxed::Box, format, vec::Vec};
+   |                         ^^^^^^  ^^^^^^^^
+
+warning: unused import: `MemoryRegion`
+  --> kernel/src/main.rs:21:87
+   |
+21 | use bootloader_api::{BootInfo, BootloaderConfig, config::Mapping, entry_point, info::{MemoryRegion, MemoryRegionKind}};
+   |                                                                                       ^^^^^^^^^^^^
+
+warning: unused import: `structures::paging::FrameAllocator`
+  --> kernel/src/main.rs:25:24
+   |
+25 | use x86_64::{VirtAddr, structures::paging::FrameAllocator};
+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+warning: unused import: `self`
+  --> kernel/src/main.rs:30:123
+   |
+30 |     framebuffer::{Color, init_global_framebuffer}, interrupts::exception::ExceptionStackFrame, memory::{frame_allocator::{self, BootInfoFrameAllocator}, paging::ActivePageTable}, repl:...
+   |                                                                                                                           ^^^^
+
+warning: unused import: `GlobalAlloc`
+   --> kernel/src/main.rs:199:27
+    |
+199 |         use core::alloc::{GlobalAlloc, Layout};
+    |                           ^^^^^^^^^^^
+
+error: unsafe attribute used without unsafe
+  --> kernel/src/process/trapret.rs:14:3
+   |
+14 | #[naked]
+   |   ^^^^^ usage of unsafe attribute
+   |
+help: wrap the attribute in `unsafe(...)`
+   |
+14 | #[unsafe(naked)]
+   |   +++++++     +
+
+error: unsafe attribute used without unsafe
+  --> kernel/src/process/trapret.rs:55:3
+   |
+55 | #[naked]
+   |   ^^^^^ usage of unsafe attribute
+   |
+help: wrap the attribute in `unsafe(...)`
+   |
+55 | #[unsafe(naked)]
+   |   +++++++     +
+
+error[E0605]: non-primitive cast: `F` as `*const ()`
+   --> kernel/src/memory/user_code.rs:101:17
+    |
+101 |     let start = func as *const () as usize;
+    |                 ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object
+
+error[E0606]: casting `&Box<TrapFrame>` as `*const TrapFrame` is invalid
+   --> kernel/src/process/context.rs:122:34
+    |
+122 |                     let tf_ptr = tf as *const super::trapframe::TrapFrame;
+    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+error[E0599]: no variant or associated item named `Blocked` found for enum `ProcessState` in the current scope
+   --> kernel/src/process/scheduler.rs:164:44
+    |
+164 |                 proc.state = ProcessState::Blocked;
+    |                                            ^^^^^^^ variant or associated item not found in `ProcessState`
+    |
+   ::: kernel/src/process/mod.rs:24:1
+    |
+ 24 | pub enum ProcessState {
+    | --------------------- variant or associated item `Blocked` not found for this enum
+
+error[E0599]: no variant or associated item named `Blocked` found for enum `ProcessState` in the current scope
+   --> kernel/src/process/scheduler.rs:172:44
+    |
+172 |             if proc.state == ProcessState::Blocked {
+    |                                            ^^^^^^^ variant or associated item not found in `ProcessState`
+    |
+   ::: kernel/src/process/mod.rs:24:1
+    |
+ 24 | pub enum ProcessState {
+    | --------------------- variant or associated item `Blocked` not found for this enum
+
+error[E0609]: no field `user_stack` on type `&mut Process`
+   --> kernel/src/process/scheduler.rs:188:51
+    |
+188 |                 if let Some(user_stack) = process.user_stack {
+    |                                                   ^^^^^^^^^^ unknown field
+    |
+    = note: available fields are: `pid`, `state`, `context`, `kernel_stack`, `trapframe` ... and 3 others
+
+warning: variable does not need to be mutable
+   --> kernel/src/allocator/buddy_allocator.rs:125:13
+    |
+125 |         let mut current_addr = addr;
+    |             ----^^^^^^^^^^^^
+    |             |
+    |             help: remove this `mut`
+    |
+    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default
+
+warning: unused variable: `pid`
+  --> kernel/src/process/scheduler.rs:72:21
+   |
+72 |                 let pid = proc.pid;
+   |                     ^^^ help: if this is intentional, prefix it with an underscore: `_pid`
+   |
+   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
+
+warning: unnecessary `unsafe` block
+   --> kernel/src/main.rs:329:26
+    |
+329 |         let page_table = unsafe {
+    |                          ^^^^^^ unnecessary `unsafe` block
+    |
+    = note: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default
+
+warning: unnecessary `unsafe` block
+   --> kernel/src/main.rs:352:26
+    |
+352 |         let page_table = unsafe {
+    |                          ^^^^^^ unnecessary `unsafe` block
+
+warning: unnecessary `unsafe` block
+   --> kernel/src/main.rs:373:26
+    |
+373 |         let page_table = unsafe {
+    |                          ^^^^^^ unnecessary `unsafe` block
+
+Some errors have detailed explanations: E0425, E0599, E0605, E0606, E0609, E0658.
+For more information about an error, try `rustc --explain E0425`.
+warning: `kernel` (bin "kernel") generated 16 warnings
+error: could not compile `kernel` (bin "kernel") due to 11 previous errors; 16 warnings emitted
